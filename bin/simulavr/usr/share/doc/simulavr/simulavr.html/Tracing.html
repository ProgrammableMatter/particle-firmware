<html lang="en">
<head>
<title>Tracing - SimulAVR Documentation 1.0.0</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="SimulAVR Documentation 1.0.0">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="Using-with-avr_002dgdb.html#Using-with-avr_002dgdb" title="Using with avr-gdb">
<link rel="next" href="Graphic-User-Interface.html#Graphic-User-Interface" title="Graphic User Interface">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This file documents the simulavr program.

Copyright (C) 2001, 2002, 2003 Theodore A. Roth

Copyright (C) 2004 Theodore A. Roth, Klaus Rudolph

Copyright (C) 2005 Klaus Rudolph

Copyright (C) 2008 Knut Schwichtenberg

Copyright (C) 2009 Joel Sherrill, Michael Hennebry, Onno Kortmann, Thomas Klepp


   Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Free Software Foundation.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Tracing"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Graphic-User-Interface.html#Graphic-User-Interface">Graphic User Interface</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Using-with-avr_002dgdb.html#Using-with-avr_002dgdb">Using with avr-gdb</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<h2 class="chapter">4 Tracing</h2>

<p><a name="index-Tracing-4"></a>
One of the core features is tracing one or multiple AVR cores in the
simulator.  To enable the trace feature you have simply to add the
<samp><span class="command">-t</span></samp> option to the command line.  If the ELF-file you load into
the simulator has debug information the trace output will also contain
the label information of the ELF-file. This information is printed for
all variables in flash, RAM, ext-RAM and also for all known hardware
registers.  Also all code labels will be written to the trace output.

   <p>What is written to trace output:
<pre class="smallexample">     2000 a.out 0x0026: __do_copy_data                 LDI R17, 0x00 R17=0x00
     2250 a.out 0x0028: __do_copy_data+0x1             LDI R26, 0x60 R26=0x60 X=0x0060
     2500 a.out 0x002a: __do_copy_data+0x2             LDI R27, 0x00 R27=0x00 X=0x0060
     2750 a.out 0x002c: __do_copy_data+0x3             LDI R30, 0x22 R30=0x22 Z=0x0022
     3000 a.out 0x002e: __do_copy_data+0x4             LDI R31, 0x01 R31=0x01 Z=0x0122
     3250 a.out 0x0030: __do_copy_data+0x5             RJMP 38
     3500 a.out 0x0038: .do_copy_data_start            CPU-waitstate
     3750 a.out 0x0038: .do_copy_data_start            CPI R26, 0x60 SREG=[------Z-]
     4000 a.out 0x003a: .do_copy_data_start+0x1        CPC R27, R17 SREG=[------Z-]
     4250 a.out 0x003c: __SP_L__                       BRNE -&gt;0x0032 .do_copy_data_loop
     4500 a.out 0x003e: __SREG__,__SP_H__,__do_clear_bss LDI R17, 0x00 R17=0x00
     4750 a.out 0x0040: __SREG__,__SP_H__,__do_clear_bss+0x1 LDI R26, 0x60 R26=0x60 X=0x0060
     5000 a.out 0x0042: __SREG__,__SP_H__,__do_clear_bss+0x2 LDI R27, 0x00 R27=0x00 X=0x0060
     5250 a.out 0x0044: __SREG__,__SP_H__,__do_clear_bss+0x3 RJMP 48
     5500 a.out 0x0048: .do_clear_bss_start            CPU-waitstate
</pre>
   <p>What the columns mean:

     <ul>
<li>absolute time value, it is measured in microseconds (us)
<li>the code you simulate, normally shown as the file name of the loaded executable file.  If your simulation runs multiple cores with multiple files you can see which core is stepping with which instruction. 
<li>actual PC, meaning bytes not instructions! The original AVR
documentation often writes in instructions, but here we write number of
flash bytes. 
<li>label corresponding to the address. The label is shown for all
known labels from the loaded ELF-file.  If multiple labels are located
to one address all labels are printed. In future releases it is maybe
possible to give some flags for the labels which would be printed. This
is dependent on the ELF-file and BFD-library. 
<li>after the label a potential offset to that label is printed. For
example <samp><span class="command">main+0x6</span></samp> which means 6 instructions after the
<samp><span class="command">main</span></samp> label is defined. 
<li>The decoded AVR instruction. Keep in mind pseudo-opcodes. If
you wonder why you write an assembler instruction one way and get
another assembler instruction here you have to think about the Atmel
AVR instruction set. Some instructions are not really available in
the AVR-core. These instructions are only supported for convenience
(i.e. are pseudo-ops) not actual opcodes for the hardware. For example,
<samp><span class="command">CLR R16</span></samp> is in the real world on the AVR-core <samp><span class="command">EOR
R16,R16</span></samp> which means exclusive or with itself which results also in zero. 
<li>operands for the instruction. If the operands access memory or registers the actual values of the operands will also be shown.
          <ul>
<li>If the operands access memory (Flash, RAM) also the labels of the accessed addresses will be written for convenience. 
<li>If a register is able to build a special value with 16 bits range (X,Y,Z) also the new value for this pseudo register is printed. 
<li>If a branch/jump instruction is decoded the branch or jump target is also decoded with the label name and absolute address also if the branch
  or jump is relative. 
<li>A special instruction <samp><span class="command">CPU-waitstate</span></samp> will be written to
the output if the core needs more then one cycle for the instruction. 
Sometimes a lot of wait states will be generated e.g. for eeprom access. 
</ul>
     <li>if the status register is affected also the <samp><span class="command">SREG=[------Z-]</span></samp> is shown.

   </ul>

   <p><b>Attention:</b> If you want to run the simulator in connection to the
avr-gdb interface and run the trace in parallel you have to keep in mind
that you MUST load the file in avr-gdb and also in the simulator from
command-line or script. It is not possible to transfer the symbols from
the ELF-file through the avr-gdb interface. For that reason you always
must give the same ELF-file for avr-gdb and for simulavr. If you load
another ELF-file via the avr-gdb interface to the simulator the symbols
for tracing could not be updated which means that the label information
in the trace output is wrong. That is not a bug, this is related to the
possibilities of the avr-gdb interface.

<!-- node-name,  next,  previous,  up -->
   </body></html>

